import{_ as e,o,c as l,V as a}from"./chunks/framework.d844f6b8.js";const _=JSON.parse('{"title":"模块化","description":"","frontmatter":{},"headers":[],"relativePath":"nodejs/module.md","filePath":"nodejs/module.md","lastUpdated":1688188058000}'),d={name:"nodejs/module.md"},i=a('<h1 id="模块化" tabindex="-1">模块化 <a class="header-anchor" href="#模块化" aria-label="Permalink to &quot;模块化&quot;">​</a></h1><h2 id="模块化概念" tabindex="-1">模块化概念 <a class="header-anchor" href="#模块化概念" aria-label="Permalink to &quot;模块化概念&quot;">​</a></h2><ul><li>模块化是指解决一个复杂问题时，自顶向下逐层把系统划分为若干模块的过程，模块是可组合、分解和更换的单元。</li><li>模块化可提高代码的复用性和可维护性，实现按需加载。</li><li>模块化规范是对代码进行模块化拆分和组合时需要遵守的规则，如使用何种语法格式引用模块和向外暴露成员。</li></ul><h2 id="node-js-中模块的分类" tabindex="-1">Node.js 中模块的分类 <a class="header-anchor" href="#node-js-中模块的分类" aria-label="Permalink to &quot;Node.js 中模块的分类&quot;">​</a></h2><ul><li>内置模块</li><li>自定义模块</li><li>第三方模块</li></ul><h2 id="node-js-中的模块作用域" tabindex="-1">Node.js 中的模块作用域 <a class="header-anchor" href="#node-js-中的模块作用域" aria-label="Permalink to &quot;Node.js 中的模块作用域&quot;">​</a></h2><ul><li>和函数作用域类似，在自定义模块中定义的变量、方法等成员，只能在当前模块内被访问，这种模块级别的访问限制，叫做模块作用域</li><li>防止全局变量污染</li></ul><h2 id="模块作用域的成员" tabindex="-1">模块作用域的成员 <a class="header-anchor" href="#模块作用域的成员" aria-label="Permalink to &quot;模块作用域的成员&quot;">​</a></h2><ul><li>自定义模块中都有一个 <code>module</code> 对象，存储了和当前模块有关的信息</li><li>在自定义模块中，可以使用 <code>module.exports</code> 对象，将模块内的成员共享出去，供外界使用。导入自定义模块时，得到的就是 <code>module.exports</code> 指向的对象。</li><li>默认情况下，<code>exports</code> 和 <code>module.exports</code> 指向同一个对象。最终共享的结果，以 <code>module.exports</code> 指向的对象为准。</li></ul><h2 id="commonjs-模块化规范" tabindex="-1">CommonJS 模块化规范 <a class="header-anchor" href="#commonjs-模块化规范" aria-label="Permalink to &quot;CommonJS 模块化规范&quot;">​</a></h2><ul><li>每个模块内部，<code>module</code> 变量代表当前模块</li><li><code>module</code> 变量是一个对象，<code>module.exports</code> 是对外的接口</li><li>加载某个模块即加载该模块的 <code>module.exports</code> 属性</li></ul><h2 id="模块加载机制" tabindex="-1">模块加载机制 <a class="header-anchor" href="#模块加载机制" aria-label="Permalink to &quot;模块加载机制&quot;">​</a></h2><p>模块第一次加载后会被缓存，即多次调用 <code>require()</code> 不会导致模块的代码被执行多次，提高模块加载效率。</p><h3 id="内置模块加载" tabindex="-1">内置模块加载 <a class="header-anchor" href="#内置模块加载" aria-label="Permalink to &quot;内置模块加载&quot;">​</a></h3><p>内置模块加载优先级最高。</p><h3 id="自定义模块加载" tabindex="-1">自定义模块加载 <a class="header-anchor" href="#自定义模块加载" aria-label="Permalink to &quot;自定义模块加载&quot;">​</a></h3><p>加载自定义模块时，路径要以 <code>./</code> 或 <code>../</code> 开头，否则会作为内置模块或第三方模块加载。</p><p>导入自定义模块时，若省略文件扩展名，则 Node.js 会按顺序尝试加载文件：</p><ul><li>按确切的文件名加载</li><li>补全 <code>.js</code> 扩展名加载</li><li>补全 <code>.json</code> 扩展名加载</li><li>补全 <code>.node</code> 扩展名加载</li><li>报错</li></ul><h3 id="第三方模块加载" tabindex="-1">第三方模块加载 <a class="header-anchor" href="#第三方模块加载" aria-label="Permalink to &quot;第三方模块加载&quot;">​</a></h3><ul><li><p>若导入第三方模块， Node.js 会从<strong>当前模块的父目录</strong>开始，尝试从 <code>/node_modules</code> 文件夹中加载第三方模块。</p></li><li><p>如果没有找到对应的第三方模块，则移动到再<strong>上一层父目录</strong>中，进行加载，直到<strong>文件系统的根目录</strong>。 例如，假设在 <code>C:\\Users\\bruce\\project\\foo.js</code> 文件里调用了 <code>require(&#39;tools&#39;)</code>，则 Node.js 会按以下顺序查找：</p></li><li><p>C:\\Users\\bruce\\project\\node_modules\\tools</p></li><li><p>C:\\Users\\bruce\\node_modules\\tools</p></li><li><p>C:\\Users\\node_modules\\tools</p></li><li><p>C:\\node_modules\\tools</p></li></ul><h3 id="目录作为模块加载" tabindex="-1">目录作为模块加载 <a class="header-anchor" href="#目录作为模块加载" aria-label="Permalink to &quot;目录作为模块加载&quot;">​</a></h3><p>当把目录作为模块标识符进行加载的时候，有三种加载方式：</p><ul><li>在被加载的目录下查找 <code>package.json</code> 的文件，并寻找 <code>main</code> 属性，作为 <code>require()</code> 加载的入口</li><li>如果没有 <code>package.json</code> 文件，或者 <code>main</code> 入口不存在或无法解析，则 Node.js 将会试图加载目录下的 <code>index.js</code> 文件。</li><li>若失败则报错</li></ul>',24),r=[i];function c(s,t,n,u,h,m){return o(),l("div",null,r)}const b=e(d,[["render",c]]);export{_ as __pageData,b as default};
